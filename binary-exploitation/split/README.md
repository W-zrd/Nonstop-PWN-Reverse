**Keyword:** Buffer Overflow, Return Oriented Programming

**Challenge URL:** https://ropemporium.com/challenge/split.html

### Case Identification
A simple Return-Oriented Programming challenge which requires us to exploit buffer overflow vulnerability to execute a specific command that will read the flag. Here is the information of the file:

![alt](img/split1.png)

There are 3 user-defined functions in the binary file: `main`, `pwnme`, and `usefulFunction`. The vulnerable part is in the `pwnme()` function, especially in this line: `read(0,local_28,0x60)`. Here is the disassembled code of `pwnme` function:
```c
void pwnme(void)
{
  undefined local_28 [32];
  
  memset(local_28,0,0x20);
  puts("Contriving a reason to ask user for data...");
  printf("> ");
  read(0,local_28,0x60);
  puts("Thank you!");
  return;
}
```

The buffer `local_28` can only hold 32 bytes safely, but the `read()` function is allowed to write up to 96 bytes into this buffer. This means we can write 64 bytes more than the buffer can safely hold. The first 32 bytes fill the buffer as intended. The next 64 bytes will overflow the buffer and write into adjacent memory.

So our ideas is to craft input that's longer than 32 bytes. The extra bytes can be designed to change where the program goes next.


### Solution

To-do