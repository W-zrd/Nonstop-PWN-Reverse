## Racecar
**Keyword: Format String Vulnerability**

**Challenge URL:** https://app.hackthebox.com/challenges/racecar

### Case Identification
This challenge gives us an executable file with all seurity protection enabled. There are many user-defined functions in disassembled code, but some of them are just printing out the menu or text message which is not too useful for solving the challenge. 

![alt](/img/racecar1.png)

We just need to focus on the `car_menu` because user input occurs in this function. Based on disassembled `car_menu` function, **If the user wins the race, the program prompts the user to enter a message**. It then attempts to open a file named "flag.txt" and reads its contents.

So **our main goal** is to trigger the program to prompt user input so we can input our payload there. But how can we even win the race if the outcome is determined by random numbers..
```c
if (((iVar1 == 1) && (iVar2 < iVar3)) || ((iVar1 == 2 && (iVar3 < iVar2)))) {
    printf("%s\n\n[+] You won the race!! You get 100 coins!\n",&DAT_00011540);
    coins = coins + 100;
    puVar5 = &DAT_00011538;
    printf("[+] Current coins: [%d]%s\n",coins,&DAT_00011538);
    printf("\n[!] Do you have anything to say to the press after your big victory?\n> %s",
            &DAT_000119de);
    __format = (char *)malloc(0x171);
    __stream = fopen("flag.txt","r");
    if (__stream == (FILE *)0x0) {
        printf("%s[-] Could not open flag.txt. Please contact the creator.\n",&DAT_00011548,puVar5);
                    /* WARNING: Subroutine does not return */
        exit(0x69);
    }
    fgets(local_3c,0x2c,__stream);
    read(0,__format,0x170);
    puts(
        "\n\x1b[3mThe Man, the Myth, the Legend! The grand winner of the race wants the whole world to know this: \x1b[0m"
        );
    printf(__format);
}
else if (((iVar1 == 1) && (iVar3 < iVar2)) || ((iVar1 == 2 && (iVar2 < iVar3)))) {
    printf("%s\n\n[-] You lost the race and all your coins!\n",&DAT_00011548);
    coins = 0;
    printf("[+] Current coins: [%d]%s\n",0,&DAT_00011538);
}
```
The program determines the winner based on randomly generated numbers, but we can actually increase our chance to win the game. Here is how it works:
1. When you choose **car option 1 and select the circuit race (option 2)**, the relevant code block is executed:
    ```c
    if (((iVar1 == 1) && (iVar2 == 2)) || ((iVar1 == 2 && (iVar2 == 2)))) {
        iVar2 = rand();
        iVar2 = iVar2 % 10;
        iVar3 = rand();
        iVar3 = iVar3 % 100;
    }
    ```
   - In this case, `iVar2` (your car number) is generated using `rand() % 10`, which results in a number between 0 and 9.
   On the other hand, `iVar3` (the opponent's car number) is generated using `rand() % 100`, which results in a number between 0 and 99.
   - Since your car number (`iVar2`) is always less than 10 and the opponent's car number (`iVar3`) is between 0 and 99, the condition `iVar2 < iVar3` is highly likely to be satisfied, resulting in winning the race.
2. When you choose **car (option 2) and select the highway battle (option 1)**, the relevant code block is executed:
   ```c
    else if (((iVar1 == 1) && (iVar2 == 1)) || ((iVar1 == 2 && (iVar2 == 1)))) {
        iVar2 = rand();
        iVar2 = iVar2 % 100;
        iVar3 = rand();
        iVar3 = iVar3 % 10;
    }
   ```
   - In this case, `iVar2` (your car number) is generated using `rand() % 100`, which results in a number between 0 and 99. On the other hand, `iVar3` (the opponent's car number) is generated using `rand() % 10`, which results in a number between 0 and 9.

So for summarize, we can win the race if we choose either **car option 1 and circuit race (option 2)** OR **car option 2 and highway battle (option 1)**. Great, we have successfully triggered user input. Now it's time to figure out how to leverage this user input to exploit the program.

### Solution
The main vulnerability in this program is a format string vulnerability. It occurs in the `car_menu` function after you win the race. Here's the relevant code:
```c
__format = (char *)malloc(0x171);
__stream = fopen("flag.txt","r");
if (__stream == (FILE *)0x0) {
  printf("%s[-] Could not open flag.txt. Please contact the creator.\n",&DAT_00011548,puVar5);
  exit(0x69);
}
fgets(local_3c,0x2c,__stream);
read(0,__format,0x170);
puts("\n\x1b[3mThe Man, the Myth, the Legend! The grand winner of the race wants the whole world to know this: \x1b[0m");
printf(__format);
```
The vulnerability lies in the last line: `printf(__format)`. Here, the program is directly passing user input `(__format)` to `printf` without any format specifier. This allows an attacker to use format specifiers to read or write memory. Using `%x` or `%p` specifiers, you can leak values from the stack. Now the question is, what needs to be leaked?

In the `car_menu` function, we see this code:
```c
char local_3c [44];
...
fgets(local_3c,0x2c,__stream);
```
`local_3c` is a local array of 44 bytes, declared within the function. **Local variables are always stored on the stack**. The `fgets` function reads up to 44 bytes from the flag file into this local array. This way, we can leak the flag out of the stack. We can just input multiple `%p` to exploit the program.

Stack layout visualization of `car_menu` function would look something similar like this:

![alt](/img/racecar2.png)

The stack grows upwards in memory. When a function is called, new data is pushed onto the stack at lower addresses. The `printf` function expects arguments for each format specifier in the format string. If there aren't enough arguments, printf will still try to read values from the stack for each specifier.

When you call `printf(user_input)` instead of `printf("%s", user_input)`, you're allowing the user to control the format string. This means the user can include format specifiers that `printf` will try to interpret. 


![alt](/img/racecar3.png)

`printf` starts reading from where it expects the first argument to be. In this case, it's likely to start at the `__format` pointer address. Since we're not providing actual arguments to match the format specifiers, `printf` keeps reading and moving down the stack *(that's why the chall name is racecar :')*.

Each `%p` causes printf to read the next 4 bytes and move to the next `word` in memory. Since `local_3c` (containing the flag) is a local variable, it's on the stack, making it accessible via this method. This process continues for as many `%p` specifiers as you provide, potentially reading through the entire stack frame.

The key point is that each `%p` moves the read position 4 bytes down in memory. So if your input is `%p %p %p %p %p %p`, you might see output like: `0x62ab0200 0x170 0x60e76dfa 0x2d 0x7 0x26`. You can add fake flag file which contains `AAAABBBB` characters so it can be easier to spot where the flag is.

![alt](/img/racecar4.png)

[Here is the solver script](/binary-exploitation/racecar/exploit/exploit.py) that i used to implement this solution and solve the challenge.
